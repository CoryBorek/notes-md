
# IEEE 754 - 32-bit floating point numbers.
How do we retreive this item very easily and decompose the number into its smallest pieces?

We can decompose it into three parts:

Sign (one bit)
Exponent (8 bits)
Mantissa (the rest)

Once we can subdivide it, we could write the exponent, bits, and decide whether it is negative or positive.

Now we need an algorithm to encode and decode these bits.


1. Sign - 1 bit
2. Exponent - 8 bits
3. Mantissa - 23 bits.


## Example

316.625

| Sign | Exponent |        Mantissa         |
| ---- | -------- |        --------         |
|  0   | 10000111 | 00111100101000000000000 |

### Steps
#### Get sign bit
In our number, it is positive, so the sign bit is 0.

#### Convert to Binary

316 - 256 - 32 - 16 - 8 - 4 = 0

1011 1100
AC

0.625 1/2 + 1/8 =

101

10111100.101

#### Scientific Notation (Base 2)
$$1.0111100101 * 2^8$$

#### Encode the Exponent
$$2^8$$

We can ignore the 2, as this is implied.

We can add 127 to the actual value

8 encoded is 0000 1000

We can add 127, or, there is a little hack.

0 = 1000 0000

If we add 8 to this, we get 1000 1000 or 0x88.

#### Encode the MAntiss

Store all bits right of the decimal point.

0111100101

Not any of the other bits.


## Decoding

| Sign | Exponent | Mantissa |
| ---- | -------- | -------- |
|  1   | 01111010 | 1011 0.. |


#### Decode Exponent
In this case, the sign is 1, so it is negative.

0111 1010 = 122
122 - 127 = -5

#### Decode Sign

It's negative 

#### Decode Mantissa

Put the understood 1 back in.

1.1011

#### Scientific Notation (base 2)
Then we can write it in scientific notation.

$$ -1.1011_2 * 2^{-5} $$

## Zero Encoding

| Sign | Exponent | Mantissa |
| ---- | -------- | -------- |
|   0  | 00000000 | 00000... |

Decode above:

$$ 1.0 * 2^-127 $$

Works for almost every case, but 0.

We define 32 bits of 0 as the encoding of $$0_{10}$$.

$$ 1.0 * 2^{-127} $$ cannot be stored in 32 bits.